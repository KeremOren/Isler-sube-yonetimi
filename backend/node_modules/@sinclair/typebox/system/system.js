"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
const Types = require("../typebox");
class TypeSystemDuplicateTypeKind extends Error {
    constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
    }
}
exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
class TypeSystemDuplicateFormat extends Error {
    constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
    }
}
exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;

var TypeSystem;
(function (TypeSystem) {
    
    TypeSystem.ExactOptionalPropertyTypes = false;
   
    TypeSystem.AllowArrayObjects = false;
    
    TypeSystem.AllowNaN = false;
    
    TypeSystem.AllowVoidNull = false;
    
    function Type(kind, check) {
        if (Types.TypeRegistry.Has(kind))
            throw new TypeSystemDuplicateTypeKind(kind);
        Types.TypeRegistry.Set(kind, check);
        return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
    }
    TypeSystem.Type = Type;
    
    function Format(format, check) {
        if (Types.FormatRegistry.Has(format))
            throw new TypeSystemDuplicateFormat(format);
        Types.FormatRegistry.Set(format, check);
        return format;
    }
    TypeSystem.Format = Format;
   
    /** @deprecated Use `TypeSystem.Type()` instead. */
    function CreateType(kind, check) {
        return Type(kind, check);
    }
    TypeSystem.CreateType = CreateType;
    /** @deprecated Use `TypeSystem.Format()` instead.  */
    function CreateFormat(format, check) {
        return Format(format, check);
    }
    TypeSystem.CreateFormat = CreateFormat;
})(TypeSystem = exports.TypeSystem || (exports.TypeSystem = {}));
